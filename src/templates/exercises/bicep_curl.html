<!-- Both Hands and elbow shoulder and hips angle -->

<!DOCTYPE html>
<html lang="en">

<head>
  <style>
        html, body {
            margin: 0;
            padding: 0;
        }

        canvas {
            display: block;
            margin: auto;
            position: fixed;
            top: 1%;
            bottom: 0;
            left: 0;
            right: 45%;
            border: 4px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 80%;
            height: 80%;
        }

        .button-container {
            position: fixed;
            bottom: 45px;
            left: 25%;
            transform: translateX(-50%);
        }

        .button-container button {
            padding: 10px 30px;
            font-size: 24px;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .button-container button:hover {
            background-color: #0056b3;
        }

        #resetButton {
            margin-left: 60px;
        }
  </style>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <!-- Require the peer dependencies of pose-detection. -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>

  <!-- You must explicitly require a TF.js backend if you're not using the TF.js union bundle. -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
  <!-- Alternatively you can use the WASM backend: <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm/dist/tf-backend-wasm.js"></script> -->

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>

  <!-- <link rel="stylesheet" type="text/css" href="style.css"> -->
  <meta charset="utf-8" />

</head>

<body>
  <h1 style="position: fixed; top: 0px; right: 750px; font-size: 48px;background-color: #f0f0f0; padding: 15px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);">Bicep Curl Exercise</h1>

  <img src="https://miro.medium.com/v2/resize:fit:828/format:webp/0*dwKB1r6m9Gxst_do.gif"
  style="position: fixed; top: 60px; right: 300px; width: 400px;">
  
  <div id="exerciseSteps"
       style="position: fixed; top: 450px; right: 100px; background-color: #f0f0f0; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); height: 365px; font-size: 18px; line-height: 1.6;">
      <h2 style="margin-bottom: 15px;">Steps To Perform Bicep Curl Exercise:</h2>
      <ol style="padding-left: 20px;">
        <li>Stand tall with a dumbbell in each hand, arms extended by your sides, palms facing forward.</li>
        <li>Keep your feet shoulder-width apart for stability.</li>
        <li>Engage your core muscles to maintain a stable posture throughout the exercise.</li>
        <li>Exhale and bend your elbows to lift the dumbbells towards your shoulders and keep upper arm straight</li>
        <li>Focus on squeezing your biceps at the top of the movement.</li>
        <li>Keep your wrists straight and avoid using momentum to swing the weights.</li>
        <li>Inhale and lower the dumbbells back down to the starting position in a controlled manner.</li>
        <li>Keep your elbows close to your body throughout the movement.</li>
        <li>Repeat for the desired number of repetitions, maintaining proper form.</li>
        <li>Adjust the weight as needed to challenge your biceps while maintaining good technique.</li>
      </ol>
  </div>
  
  <div class="button-container">
      <button id="resetButton">Reset</button>
  </div>
  <script>
    let detector;
    let detectorConfig;
    let poses;
    let video;
    let skeleton = true;
    let model;
    let elbowAngle = 999;
    let backAngle = 0;
    let reps = 0;
    let upPosition = false;
    let downPosition = false;
    let highlightArm = true;
    let armWarningGiven = false;
    let currentFPS = 0;
    let canvasWidth = 960;
    let canvasHeight = 720;
    let scaleFactorX, scaleFactorY;

    async function init() {
      detectorConfig = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_THUNDER };
      detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, detectorConfig);
      edges = {
        '5,7': 'm',
        '7,9': 'm',
        '6,8': 'c',
        '8,10': 'c',
        '5,6': 'y',
        '5,11': 'm',
        '6,12': 'c',
        '11,12': 'y',
        '11,13': 'm',
        '13,15': 'm',
        '12,14': 'c',
        '14,16': 'c'
      };
      await getPoses();
    }

    async function videoReady() {
      scaleFactorX = canvasWidth / video.width;
        scaleFactorY = canvasHeight / video.height;
    }

    async function setup() {
        createCanvas(canvasWidth, canvasHeight);
        video = createCapture(VIDEO, videoReady);
        video.hide()
        await init();
    }

    async function getPoses() {
      poses = await detector.estimatePoses(video.elt);
      setTimeout(getPoses, 0);
    }

    function draw() {
        background(220);
        translate(width, 0);
        scale(-1, 1);
        image(video, 0, 0, canvasWidth, canvasHeight);
        drawKeypoints();
        if (skeleton) {
            drawSkeleton();
        }
        currentFPS = frameRate();
        fill(255);
        textSize(20);
        push();
        translate(width, 0);
        scale(-1, 1);
        text(`FPS: ${currentFPS.toFixed(2)}`, 20, 20);
        pop();

        fill(255);
        strokeWeight(2);
        stroke(51);
        translate(width, 0);
        scale(-1, 1);
        textSize(60);

        if (poses && poses.length > 0) {
            let pushupString = `Reps Completed: ${reps}`;
            text(pushupString, 200, 700);
        } else {
            text('Loading, please wait...', 200, 700);
        }
    }

    function drawKeypoints() {
        var count = 0;
        if (poses && poses.length > 0) {
            for (let kp of poses[0].keypoints) {
                const {x, y, score} = kp;
                if (score > 0.3) {
                    count = count + 1;
                    fill(255);
                    stroke(0);
                    strokeWeight(4);
                    circle(x * scaleFactorX, y * scaleFactorY, 16);
                }
                updateArmAngle();
                updateShoulderAngle();
                inUpPosition();
                inDownPosition();
            }
        }
    }

    function drawSkeleton() {
        confidence_threshold = 0.5;
        if (poses && poses.length > 0) {
            for (const [key, value] of Object.entries(edges)) {
                const p = key.split(",");
                const p1 = p[0];
                const p2 = p[1];

                const y1 = poses[0].keypoints[p1].y * scaleFactorY;
                const x1 = poses[0].keypoints[p1].x * scaleFactorX;
                const c1 = poses[0].keypoints[p1].score;
                const y2 = poses[0].keypoints[p2].y * scaleFactorY;
                const x2 = poses[0].keypoints[p2].x * scaleFactorX;
                const c2 = poses[0].keypoints[p2].score;

                if ((c1 > confidence_threshold) && (c2 > confidence_threshold)) {
                    if ((highlightArm == true) && (p[0] == '7' || p[0] == '8' || p[1] == '7' || p[1] == '8')) {
                        strokeWeight(3);
                        stroke(255, 0, 0);
                        line(x1, y1, x2, y2);
                    } else {
                        strokeWeight(2);
                        stroke('rgb(0, 255, 0)');
                        line(x1, y1, x2, y2);
                    }
                }
            }
        }
    }

    function updateArmAngle() {
    
      rightWrist = poses[0].keypoints[10];
      rightShoulder = poses[0].keypoints[6];
      rightElbow = poses[0].keypoints[8];
      
      leftWrist = poses[0].keypoints[9];
      leftShoulder = poses[0].keypoints[5];
      leftElbow = poses[0].keypoints[7];

      leftAngle = (Math.atan2(leftWrist.y - leftElbow.y, leftWrist.x - leftElbow.x) -
                Math.atan2(leftShoulder.y - leftElbow.y, leftShoulder.x - leftElbow.x)) * (180 / Math.PI);
            
            if ((leftAngle > 10 && leftAngle < 30) || (leftAngle > 155 && leftAngle < 175)) {
              // highlightArm = false; 
            } else {
              // highlightArm = true;
                if (!armWarningGiven) {
                    var msg = new SpeechSynthesisUtterance('Keep your arms closed to your body');
                    window.speechSynthesis.speak(msg);
                    armWarningGiven = true;
                }
            }
            // console.log(`left elbow:`, leftAngle);

            if (leftAngle < 0) {
                // leftAngle = leftAngle + 360;
            }

            if (leftShoulder.score > 0.3 && leftElbow.score > 0.3 && leftWrist.score > 0.3) {
              leftAngle = leftAngle;
            }

        // Right arm angle calculation
        rightWrist = poses[0].keypoints[10];
        rightShoulder = poses[0].keypoints[6];
        rightElbow = poses[0].keypoints[8];

            rightAngle = (
                Math.atan2(rightWrist.y - rightElbow.y, rightWrist.x - rightElbow.x) -
                Math.atan2(rightShoulder.y - rightElbow.y, rightShoulder.x - rightElbow.x)
            ) * (180 / Math.PI);
        
            // console.log(`elbow angle right:`, rightAngle); // Log elbow angle
            if ((rightAngle < 0 && rightAngle > -20) || (rightAngle < 195 && rightAngle > 175)) {
              highlightArm = false; // Shoulder angle is not within the desired range

            } else {
              highlightArm = true; // Shoulder angle is within the desired range
                if (!armWarningGiven) {
                    var msg = new SpeechSynthesisUtterance('Keep your arms closed to your body');
                    window.speechSynthesis.speak(msg);
                    armWarningGiven = true;
                }
            }
            // console.log(`right elbow:`, rightAngle);

            if (rightAngle < 0) {
                // rightAngle = rightAngle + 360;
            }
            if (rightShoulder.score > 0.3 && rightElbow.score > 0.3 && rightWrist.score > 0.3) {
              rightAngle=rightAngle;
            }
        

    }
    
    function updateShoulderAngle() {

      var leftElbow = poses[0].keypoints[7];
      var leftShoulder = poses[0].keypoints[5];
      var leftHip = poses[0].keypoints[11];

          leftShoulderAngle = (
              Math.atan2(leftHip.y - leftShoulder.y, leftHip.x - leftShoulder.x) -
              Math.atan2(leftShoulder.y - leftElbow.y, leftShoulder.x - leftElbow.x)
          ) * (180 / Math.PI);
            // console.log(`left shoulder:`, leftShoulderAngle); 

          if (leftShoulderAngle < 0) {
              // leftShoulderAngle = leftShoulderAngle + 360;
          }
          if ((leftShoulderAngle < 205 ) && (leftShoulderAngle > 195)) {
            highlightArm = false; // Shoulder angle is not within the desired range
          } else {
            highlightArm = true; // Shoulder angle is within the desired range
              if (!armWarningGiven) {
                  var msg = new SpeechSynthesisUtterance('Keep your arms closed to your body');
                  window.speechSynthesis.speak(msg);
                  armWarningGiven = true;
              }
              if (leftElbow.score > 0.3 && leftShoulder.score > 0.3 && leftHip.score > 0.3) {
                leftShoulderAngle =leftShoulderAngle;
              }
      }

      // Right arm angle calculation
      const rightElbow = poses[0].keypoints[8];
      const rightShoulder = poses[0].keypoints[6];
      const rightHip = poses[0].keypoints[12];

          rightShoulderAngle = (
              Math.atan2(rightHip.y - rightShoulder.y, rightHip.x - rightShoulder.x) -
              Math.atan2(rightShoulder.y - rightElbow.y, rightShoulder.x - rightElbow.x)
          ) * (180 / Math.PI);
          // console.log(`right shoulder:`, rightShoulderAngle); 

          if (rightShoulderAngle < 0) {
              // rightShoulderAngle = rightShoulderAngle + 360;
          }
          if ((rightShoulderAngle < 165) && (rightShoulderAngle > 155)) {
            highlightArm = false; // Shoulder angle is not within the desired range
          } else {
            console.log(`right shoulder:`, rightShoulderAngle); 
            highlightArm = true; // Shoulder angle is within the desired range
              if (!armWarningGiven) {
                  var msg = new SpeechSynthesisUtterance('Keep your arms closed to your body');
                  window.speechSynthesis.speak(msg);
                  armWarningGiven = true;
              }
          }
          if (rightElbow.score > 0.3 && rightShoulder.score > 0.3 && rightHip.score > 0.3) {
            rightShoulderAngle = rightShoulderAngle;
          }
    }

    function inUpPosition() {
            if ((leftAngle > 10 && leftAngle < 30) && (rightAngle < 0 && rightAngle > -20) && ((leftShoulderAngle < 205 ) || (leftShoulderAngle > 195)) && ((rightShoulderAngle < 165) || (rightShoulderAngle > 155))) {
              if (downPosition == true) {
                  var msg = new SpeechSynthesisUtterance("Down");
                  window.speechSynthesis.speak(msg);            
              }
              upPosition = true;
              downPosition = false;
          }
      }

      function inDownPosition() {
          if ((leftAngle > 155 && leftAngle < 175) && (rightAngle < 195 && rightAngle > 175) && ((leftShoulderAngle < 205 ) || (leftShoulderAngle > 195)) && ((rightShoulderAngle < 165) || (rightShoulderAngle > 155))) {
              if (upPosition == true) {
                  var msg = new SpeechSynthesisUtterance(str(reps+1));
                  window.speechSynthesis.speak(msg);
                  reps = reps + 1;
              }
              upPosition = false;
              downPosition = true;
          }
      }
      const resetButton = document.getElementById('resetButton');

      // Add event listener to the reset button
      resetButton.addEventListener('click', () => {
          // Call reset function
          reps = 0;
      });
  </script>
</body>

</html>